<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Why Secret is Particularly Interesting for Reclaim | Reclaim Protocol Official Blog</title>
<meta name="keywords" content="">
<meta name="description" content="Reclaim Protocol lets users generate credentials without leaking private information. One thing we think about a lot is how to we make sure our users don’t get doxxed.
Let’s define the problem more concretely.
Say you, as a user, generated certain credentials for on-chain use. You created a credential from your Uber account, your Tinder account, your Doordash account, your Tax Records and so on. Let us assume that given enough data points on chain, it might be possible to triangulate the particular you, the user, that is interacting with a certain smart contract.">
<meta name="author" content="">
<link rel="canonical" href="https://blog.reclaimprotocol.org/posts/integration-reclaim-secret/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css" integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z&#43;V9&#43;cO1A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://blog.reclaimprotocol.org/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://blog.reclaimprotocol.org/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://blog.reclaimprotocol.org/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://blog.reclaimprotocol.org/apple-touch-icon.png">
<link rel="mask-icon" href="https://blog.reclaimprotocol.org/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://blog.reclaimprotocol.org/posts/integration-reclaim-secret/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<meta property="og:title" content="Why Secret is Particularly Interesting for Reclaim" />
<meta property="og:description" content="Reclaim Protocol lets users generate credentials without leaking private information. One thing we think about a lot is how to we make sure our users don’t get doxxed.
Let’s define the problem more concretely.
Say you, as a user, generated certain credentials for on-chain use. You created a credential from your Uber account, your Tinder account, your Doordash account, your Tax Records and so on. Let us assume that given enough data points on chain, it might be possible to triangulate the particular you, the user, that is interacting with a certain smart contract." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://blog.reclaimprotocol.org/posts/integration-reclaim-secret/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-27T10:00:09-04:00" />
<meta property="article:modified_time" content="2024-03-27T10:00:09-04:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Why Secret is Particularly Interesting for Reclaim"/>
<meta name="twitter:description" content="Reclaim Protocol lets users generate credentials without leaking private information. One thing we think about a lot is how to we make sure our users don’t get doxxed.
Let’s define the problem more concretely.
Say you, as a user, generated certain credentials for on-chain use. You created a credential from your Uber account, your Tinder account, your Doordash account, your Tax Records and so on. Let us assume that given enough data points on chain, it might be possible to triangulate the particular you, the user, that is interacting with a certain smart contract."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://blog.reclaimprotocol.org/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Why Secret is Particularly Interesting for Reclaim",
      "item": "https://blog.reclaimprotocol.org/posts/integration-reclaim-secret/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Why Secret is Particularly Interesting for Reclaim",
  "name": "Why Secret is Particularly Interesting for Reclaim",
  "description": "Reclaim Protocol lets users generate credentials without leaking private information. One thing we think about a lot is how to we make sure our users don’t get doxxed.\nLet’s define the problem more concretely.\nSay you, as a user, generated certain credentials for on-chain use. You created a credential from your Uber account, your Tinder account, your Doordash account, your Tax Records and so on. Let us assume that given enough data points on chain, it might be possible to triangulate the particular you, the user, that is interacting with a certain smart contract.",
  "keywords": [
    
  ],
  "articleBody": "Reclaim Protocol lets users generate credentials without leaking private information. One thing we think about a lot is how to we make sure our users don’t get doxxed.\nLet’s define the problem more concretely.\nSay you, as a user, generated certain credentials for on-chain use. You created a credential from your Uber account, your Tinder account, your Doordash account, your Tax Records and so on. Let us assume that given enough data points on chain, it might be possible to triangulate the particular you, the user, that is interacting with a certain smart contract. If that is true, you are doxxed which can lead to various downstream problems including censoring and off-chain penalties. And this is a doxxing of a special kind - it is permanent. Because it is onchain.\nThat sucks.\nOne solution is to have different wallets for different credentials and different contracts. But, these days it’s easy to figure out the owner of all the wallets using some advanced chain analysis. Particularly, tracing back where the eth for transaction fees came from.\nReclaim has a way to solve this problem. That is, whenever you create a credential, you add yourself to a Merkel tree. At any point, this Merkel tree represents the set of users who have generated the credential. Now, when interacting with a smart contract, you don’t submit the reclaim proof - but rather a merkel tree membership zkproof. So, all that the contract or someone doing the chain analysis learns is that you were one of the several members of the merkel tree, but never know which one in particular. This is works. It is live on our EVM smart contracts.\nHowever, this converts what is a one step process into a two step process with additional delay. That is, you first need to add yourself to a merkel tree using a reclaim proof and then share the zkp of merkel tree membership with the smart contract instead of submitting the reclaim proof directly. Additionally, if you are the first person to create a credential, you also need to wait for numerous people to join the merkel tree before you can be sure that you don’t doxx yourself even when using the zkproof of merkel tree membership.\nIt’s a UX hassle.\nThat is where we are super excited to work with Secret. Because all the transactions are processed inside a TEE, you can submit a Reclaim proof directly to the smart contract you want to interact with - without the additional step of adding yourself to a merkel tree and waiting for enough members to join. All the data to and from the TEEs are encrypted too, so that makes the UX great without compromising security.\nWe are proud to say that we’re live on Secret as of today and are ready to help Dapps that want to build using Reclaim Protocol integrate in a way that users don’t get doxxed. This is something any dapp on Cosmos can start integrating today!\nFuture Directions - controlled information sharing with Secret Another potential direction to combine Reclaim with Secret Network is to store multi-value Reclaim proofs in a smart contract on Secret, and have the Smart Contract govern access to data. For example, a user may store proofs of several different data points, like their age, their audited income, number of their followers on social networks, etc. The user may than decide to allow the contract to share certain parts of the information with other smart contracts. For instance, the user may allow a gaming app to get a proof that the user is over 21, or a trading app to get a proof that the user’s income is in a certain bracket. Other apps may need more granular access, but the user will be in control of who gets to see what data.\nSpecial thanks to Alex Zaidelson for his continued support and on-the-fly error fixing to help us get to production in a short span!\n",
  "wordCount" : "662",
  "inLanguage": "en",
  "datePublished": "2024-03-27T10:00:09-04:00",
  "dateModified": "2024-03-27T10:00:09-04:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://blog.reclaimprotocol.org/posts/integration-reclaim-secret/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Reclaim Protocol Official Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://blog.reclaimprotocol.org/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://blog.reclaimprotocol.org/" accesskey="h" title="Reclaim Protocol Official Blog (Alt + H)">Reclaim Protocol Official Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                </ul>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Why Secret is Particularly Interesting for Reclaim
    </h1>
    <div class="post-meta"><span title='2024-03-27 10:00:09 -0400 EDT'>March 27, 2024</span>

</div>
  </header> 
  <div class="post-content"><p>Reclaim Protocol lets users generate credentials without leaking private information. One thing we think about a lot is how to we make sure our users don’t get doxxed.</p>
<p>Let’s define the problem more concretely.</p>
<p>Say you, as a user, generated certain credentials for on-chain use. You created a credential from your Uber account, your Tinder account, your Doordash account, your Tax Records and so on. Let us assume that given enough data points on chain, it might be possible to triangulate the particular you, the user, that is interacting with a certain smart contract. If that is true, you are doxxed which can lead to various downstream problems including censoring and off-chain penalties. And this is a doxxing of a special kind - it is permanent. Because it is onchain.</p>
<p>That sucks.</p>
<p>One solution is to have different wallets for different credentials and different contracts. But, these days it’s easy to figure out the owner of all the wallets using some advanced chain analysis. Particularly, tracing back where the eth for transaction fees came from.</p>
<p>Reclaim has a way to solve this problem. That is, whenever you create a credential, you add yourself to a Merkel tree. At any point, this Merkel tree represents the set of users who have generated the credential. Now, when interacting with a smart contract, you don’t submit the reclaim proof - but rather a merkel tree membership zkproof. So, all that the contract or someone doing the chain analysis learns is that you were one of the several members of the merkel tree, but never know which one in particular. This is works. It is live on our EVM smart contracts.</p>
<p>However, this converts what is a one step process into a two step process with additional delay. That is, you first need to add yourself to a merkel tree using a reclaim proof and then share the zkp of merkel tree membership with the smart contract instead of submitting the reclaim proof directly. Additionally, if you are the first person to create a credential, you also need to wait for numerous people to join the merkel tree before you can be sure that you don’t doxx yourself even when using the zkproof of merkel tree membership.</p>
<p>It’s a UX hassle.</p>
<p>That is <em><strong>where we are super excited to work with Secret.</strong></em> Because all the transactions are processed inside a TEE, you can submit a Reclaim proof directly to the smart contract you want to interact with - without the additional step of adding yourself to a merkel tree and waiting for enough members to join. All the data to and from the TEEs are encrypted too, so that makes the UX great without compromising security.</p>
<p>We are proud to say that we’re live on Secret as of today and are ready to help Dapps that want to build using Reclaim Protocol integrate in a way that users don’t get doxxed. This is something any dapp on Cosmos can start integrating today!</p>
<h2 id="future-directions---controlled-information-sharing-with-secret">Future Directions - controlled information sharing with Secret<a hidden class="anchor" aria-hidden="true" href="#future-directions---controlled-information-sharing-with-secret">#</a></h2>
<p>Another potential direction to combine Reclaim with Secret Network is to store multi-value Reclaim proofs in a smart contract on Secret, and have the Smart Contract govern access to data. For example, a user may store proofs of several different data points, like their age, their audited income, number of their followers on social networks, etc. The user may than decide to allow the contract to share certain parts of the information with other smart contracts. For instance, the user may allow a gaming app to get a proof that the user is over 21, or a trading app to get a proof that the user’s income is in a certain bracket. Other apps may need more granular access, but the user will be in control of who gets to see what data.</p>
<p>Special thanks to <a href="https://twitter.com/azaidelson?ref_src=twsrc%5Egoogle%7Ctwcamp%5Eserp%7Ctwgr%5Eauthor">Alex Zaidelson</a> for his continued support and on-the-fly error fixing to help us get to production in a short span!</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://blog.reclaimprotocol.org/">Reclaim Protocol Official Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
