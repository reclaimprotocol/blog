<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>Proxying Is Enough | Reclaim Protocol Official Blog</title>
<meta name="keywords" content="">
<meta name="description" content="- Madhavan Malolan
Recently Z. Luo et al released a paper titled &ldquo;Proxying is Enough: Security of Proxying in TLS Oracles and AEAD Context Unforgeability&rdquo; (Hash), where they discuss security of TLS Oracles.
From the paper,&quot;TLS oracles allow a TLS client to offer selective data provenance to an external (oracle) node such that the oracle node is ensured that the data is indeed coming from a pre-defined TLS server.&quot;
In other words, A TLS Oracle proves what data the user saw when they opened a website on their browser.">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/posts/proxying-is-enough/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css" integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z&#43;V9&#43;cO1A=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/posts/proxying-is-enough/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js"></script>

<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body);"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
            delimiters: [
                {left: "$$", right: "$$", display: true},
                {left: "$", right: "$", display: false}
            ]
        });
    });
</script>



</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Reclaim Protocol Official Blog (Alt + H)">Reclaim Protocol Official Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                </ul>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Proxying Is Enough
      <span class="entry-hint" title="Draft">
        <svg xmlns="http://www.w3.org/2000/svg" height="35" viewBox="0 -960 960 960" fill="currentColor">
          <path
            d="M160-410v-60h300v60H160Zm0-165v-60h470v60H160Zm0-165v-60h470v60H160Zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22q0 11-4.5 22.5T862.09-380L643-160H520Zm300-263-37-37 37 37ZM580-220h38l121-122-18-19-19-18-122 121v38Zm141-141-19-18 37 37-18-19Z" />
        </svg>
      </span>
    </h1>
    <div class="post-meta"><span title='2024-05-29 15:40:12 -0400 EDT'>May 29, 2024</span>

</div>
  </header> 
  <div class="post-content"><p><em>- Madhavan Malolan</em></p>
<p>Recently Z. Luo et al released a paper titled <a href="https://eprint.iacr.org/2024/733.pdf">&ldquo;Proxying is Enough: Security of Proxying in TLS Oracles and AEAD Context
Unforgeability&rdquo;</a> <a href="https://etherscan.io/tx/0xa0c1f3d7a641a065688e148890a77f360b198e01e49aa28352e856682c4c12c9">(Hash)</a>, where they discuss security of TLS Oracles.</p>
<p>From the paper,&quot;<em>TLS oracles allow a TLS client to offer selective data provenance to an external (oracle) node such that the oracle node is ensured that the data is indeed coming from a pre-defined TLS server.</em>&quot;</p>
<p>In other words, A TLS Oracle proves what data the user saw when they opened a website on their browser. Browsers use HTTPS to transfer data between your device and the webserver. TLS is the security protocol used by HTTPS.</p>
<h1 id="deco-formalized-security-of-mpc-based-tls-oracles">Deco formalized security of MPC based TLS Oracles<a hidden class="anchor" aria-hidden="true" href="#deco-formalized-security-of-mpc-based-tls-oracles">#</a></h1>
<p>The first construction for using https to generate zk proofs of what data was transferred between a user and a website was proposed by F. Zhang et al in their paper <a href="https://arxiv.org/pdf/1909.00938">&ldquo;DECO: Liberating Web Data Using Decentralized Oracles for TLS&rdquo;</a>.</p>
<p>The key contribution was that they showed how they could use <a href="https://en.wikipedia.org/wiki/Secure_multi-party_computation">MPC</a> to introduce an additional stakeholder in the <a href="https://www.cloudflare.com/learning/ssl/what-happens-in-a-tls-handshake/">TLS handshake</a>, which can then be used to zk-proofs of data that was sent by the website. Optionally using selective reveals. Details of this are irrelevant for this post. All you need to know is Deco introduced an MPC based solution.</p>
<p>Along with this result, they also showed formally that this approach is secure.</p>
<h1 id="tls-notary-made-practicality-inroads">TLS Notary made practicality inroads<a hidden class="anchor" aria-hidden="true" href="#tls-notary-made-practicality-inroads">#</a></h1>
<p>Deco, the paper, was released in 2019. As of 2024, there isn&rsquo;t an efficient implementation of the described protocol as is. However, <a href="https://tlsnotary.org/">TLS Notary</a>, an open sourced project implemented a similar construct using <a href="https://en.wikipedia.org/wiki/Garbled_circuit">Garbled Circuits</a>.</p>
<p>TLS Notary is a project that one can clone and run on a consumer laptop. However, as of this writing, the data that had to be sent to-and-fro to establish an MPC using Garbled circuit ran into hundreds of MBs &ndash; making it infeasible for mass adoption.</p>
<p>But TLS Notary showed that it is possible to implement a garbled circuit based mpc three party tls handshake.</p>
<h1 id="optimizing-tls-notary">Optimizing TLS Notary<a hidden class="anchor" aria-hidden="true" href="#optimizing-tls-notary">#</a></h1>
<p>There have been several attempts to optimize the TLS Notary approach to make it viable in the wild. Particularly on mobile devices with low compute, memory and network bandwidth. Opacity, ZKPass, Pado Labs are notable projects exploring this option.</p>
<h1 id="an-alternate-model---proxying">An alternate model - Proxying<a hidden class="anchor" aria-hidden="true" href="#an-alternate-model---proxying">#</a></h1>
<p>TLS and thereby HTTPS are secured using symmetric keys. These keys don&rsquo;t help us know who encrypted the data &ndash; the website or the user? Did the user send some data to themselves and are now claiming that this data came from the server? It&rsquo;s impossible to verify. To make HTTPS data verifiable, one must introduce a third party to witness certain aspects of the HTTPS session lifecycle.</p>
<p>MPC based approaches introduce a witness at the tls handshake stage of the lifecycle. An alternate model is a Proxying model where you introduce the witness at the data transfer stage. All that the proxy does is, it witnesses the encrypted data that was tranferred from the user to the website and back. Basically, the request and the response in encrypted form, and provides an attestation to the <code>(encrypted-request, encrypted-response)</code> tuple.</p>
<p>This attested tuple can be fed to a zk circuit to selectively reveal some data from the response. Thereby producing the same output as what a TLS Notary would. <em>&ldquo;The response R contains string S, and R was indeed received from website W in response to a user request Q&rdquo;</em>.</p>
<p>This proxy based approach is much more efficient because it needs no change on the client browser because, browsers are already capable of using proxies. Additionally, doesn&rsquo;t need any heavy computation for establishing an MPC based TLS handshake.</p>
<p>Reclaim has been using the Proxy based approach, primarily because of feasibility of productizing.</p>
<h1 id="is-it-secure">Is it secure?<a hidden class="anchor" aria-hidden="true" href="#is-it-secure">#</a></h1>
<p>Deco provided a formal security analyisis of the MPC approach. Whereas, there weren&rsquo;t any formal proofs for the security of the Proxy based model.</p>
<p>This led to a wide spread understanding that the MPC approach is more secure than the Proxy model.</p>
<p>At Reclaim, we knew that the Proxy model is secure &ndash; not using formal proofs, but through engineering observations. We also had internal and <a href="https://blog.reclaimprotocol.org/posts/audits/">external security audits in place</a>. But again, these are analysis from an engineering standpoint.</p>
<p>Z Luo et al, for the first time presented a formal analysis of the security of the Proxy based approach and concluded that <em>Proxying is secure enough</em>.</p>
<h1 id="what-does-it-mean-to-be-secure">What does it mean to be secure?<a hidden class="anchor" aria-hidden="true" href="#what-does-it-mean-to-be-secure">#</a></h1>
<p>From Z Luo et al, theorem 6.1 the security is defined as the probability that someone tricked the protocol in generating a valid proof when it should have actually failed.</p>
<p>That is, if someone gives you a proof generated using Reclaim Protocol or any other proxying based TLS Oracle where the proxy is an honest operator - what is the probablity that the proof is a fraud?</p>
<p>From the paper :
<img loading="lazy" src="/images/zluo-6.1.png" alt="theorem 6.1"  />
</p>
<h2 id="using-aes-gcm-looks-very-secure">Using AES-GCM looks very secure<a hidden class="anchor" aria-hidden="true" href="#using-aes-gcm-looks-very-secure">#</a></h2>
<p>AES GCM is the most popular cryptographic algorithm used in HTTPS.
Plugging in the values for AES,</p>
<ul>
<li>$|S| = 63 * 3600$ ; using the padding used in the paper. Note this not the actual padding used by Reclaim Protocol as we will soon see.</li>
<li>$\lambda = 56*8$ ; for 56 bytes of padding, 8bits each</li>
<li>$l=128$ ; block size for AESGCM is 128 bits</li>
</ul>
<p><a href="https://www.wolframalpha.com/input?i=log_10%28%2863*3600%29%5E2%2F%282%5E%288*56+-+2*128+%2B2%29%29%29">That gives us</a> the probaility of the proof having been fradulently created to be</p>
<p>$0.0000000000000000000000000000000000000000000001$ %</p>
<p>That is an extremely small probability, and secure enough to practically say that we can be certain that the proof generated is fully secure.</p>
<h2 id="using-chacha20-looks-">Using ChaCha20 looks &hellip;<a hidden class="anchor" aria-hidden="true" href="#using-chacha20-looks-">#</a></h2>
<p>AESGCM is the most popular, but it isn&rsquo;t zk friendly. Writing zk circuits for AESGCM can be very inefficient. So, Reclaim Protocol uses ChaCha20 instead. ChaCha20 is the second most popular cryptographic algorithm in HTTPS. <a href="https://www.f5.com/labs/articles/threat-intelligence/the-2021-tls-telemetry-report">99%</a> of all the websites support ChaCha20. It is a requirement for every website to support ChaCha20 in TLS1.3 onwards.</p>
<p>Ok, so let&rsquo;s plug in those numbers</p>
<ul>
<li>$|S| = 63 * 3600$ ; stays the same</li>
<li>$\lambda = 56*8$ ; stays the same</li>
<li>$l=512$ ; block size for ChaCha20 is 512 bits</li>
</ul>
<p><a href="https://www.wolframalpha.com/input?i=log_10%28%2863*3600%29%5E2%2F%282%5E%288*56+-+2*512+%2B2%29%29%29">That gives us</a> &hellip; something wrong.</p>
<p>The formula tells us that the probability that the proof you are looking at is $10^{185}$% a fraud. That doesn&rsquo;t make sense.</p>
<ol>
<li>Probability can&rsquo;t be greater than 100%, leave alone 1 followed by 185 zeros percent.</li>
<li>This means, if you use ChaCha20, you can be (beyond) certain that the user has cheated, even when we know that the user is honest. That doesn&rsquo;t feel natural, does it?</li>
</ol>
<h2 id="we-reached-out-to-z-luo">We reached out to Z Luo<a hidden class="anchor" aria-hidden="true" href="#we-reached-out-to-z-luo">#</a></h2>
<p>When running our numbers on our actual production parameters, we realized there seems to be an issue - as we saw above. We reached out to Z Luo, who was very receptive and offered to dive deeper.</p>
<p><img loading="lazy" src="/images/zluo-discord.png" alt="zluo discord"  />
</p>
<h2 id="the-updated-formula">The updated formula<a hidden class="anchor" aria-hidden="true" href="#the-updated-formula">#</a></h2>
<p>Coming soon &hellip;</p>
<h2 id="the-real-numbers-in-production">The Real Numbers, in production<a hidden class="anchor" aria-hidden="true" href="#the-real-numbers-in-production">#</a></h2>
<p>Coming soon &hellip;</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="http://localhost:1313/">Reclaim Protocol Official Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
